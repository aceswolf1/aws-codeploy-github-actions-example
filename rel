#!/usr/bin/env bash
set -euo pipefail

# ------------------------------------------------------------
# rel â€” minimal release helper for your workflow
#
# Implements:
#   MASTER=main ./rel version pre
#
# Behavior:
# - Reads base version from ./VERSION (e.g., 0.6.0)
# - Creates/bumps pre-release tag:   0.6.0-pre.N
# - Creates matching branch name:    0.6.0-pre.N  (same as tag)
# - Pushes tag and branch to origin using explicit refspecs
#
# Env vars:
#   MASTER  main branch to operate on (default: main)
#   ORIGIN  remote name to push to    (default: origin)
#
# Notes:
# - Does not mutate files (e.g., package.json); only Git ops.
# - Requires a clean working tree.
# ------------------------------------------------------------

MASTER="${MASTER:-main}"
ORIGIN="${ORIGIN:-origin}"

die() { echo "ERROR: $*" >&2; exit 1; }

usage() {
  cat <<EOF
Usage:
  MASTER=main ./rel version pre

Environment (optional):
  MASTER=<branch>     Mainline branch to base releases from (default: main)
  ORIGIN=<remote>     Git remote to push to (default: origin)
EOF
}

require_git_clean() {
  if ! git diff --quiet || ! git diff --cached --quiet; then
    die "Working tree not clean. Commit or stash changes before running rel."
  fi
}

require_on_master_and_pull() {
  local cur
  cur="$(git rev-parse --abbrev-ref HEAD)"
  if [ "$cur" != "$MASTER" ]; then
    echo "INFO: switching to $MASTER"
    git checkout "$MASTER"
  fi
  echo "INFO: pulling latest $MASTER from $ORIGIN"
  git pull --ff-only "$ORIGIN" "$MASTER"
}

read_version_file() {
  [ -f VERSION ] || die "VERSION file not found at repo root."
  local v
  v="$(tr -d ' \t\r\n' < VERSION)"
  [ -n "$v" ] || die "VERSION file is empty."
  echo "$v"
}

# Given base '0.6.0' find next '0.6.0-pre.N'
next_pre_tag() {
  local base="$1"
  local last n
  last="$(git tag --list "${base}-pre.*" | sort -V | tail -n1 || true)"
  if [ -n "$last" ]; then
    n="$(sed -n 's/^.*-pre\.\([0-9]\+\)$/\1/p' <<<"$last")"
    [ -n "$n" ] || n=0
    echo "${base}-pre.$((n+1))"
  else
    echo "${base}-pre.0"
  fi
}

cmd_version_pre() {
  require_git_clean
  require_on_master_and_pull

  # Read and normalize base version (strip any existing -pre.* or -rc.*)
  local ver base tag branch
  ver="$(read_version_file)"
  base="${ver%%-pre.*}"
  base="${base%%-rc.*}"

  tag="$(next_pre_tag "$base")"   # e.g., 0.6.0-pre.0
  branch="$tag"                   # keep branch name identical to tag

  echo "Creating/ensuring pre-release:"
  echo "  base version : $base"
  echo "  tag          : $tag"
  echo "  branch       : $branch"

  # Create tag if missing, then push tag explicitly
  if git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
    echo "Tag ${tag} already exists locally."
  else
    echo "Creating tag: ${tag}"
    git tag -a "$tag" -m "pre-release $tag"
  fi
  echo "Pushing tag: ${tag}"
  git push "$ORIGIN" "refs/tags/${tag}:refs/tags/${tag}"

  # Ensure branch exists locally at the same commit as MASTER
  if git rev-parse -q --verify "refs/heads/${branch}" >/dev/null; then
    echo "Local branch ${branch} already exists."
  else
    echo "Creating branch at ${MASTER}: ${branch}"
    git branch "$branch" "$MASTER"
  fi

  # Push branch explicitly to avoid name collision with tag
  echo "Pushing branch: ${branch}"
  git push "$ORIGIN" "refs/heads/${branch}:refs/heads/${branch}"

  echo "Done. Tag ${tag} and branch ${branch} are present on remote."
}

# ---------- main ----------
[ $# -ge 2 ] || { usage; die "Insufficient arguments"; }

case "$1 $2" in
  "version pre") cmd_version_pre ;;
  *)
    usage
    die "Unsupported command '$1 $2'. Implemented: 'version pre'"
    ;;
esac